package main

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"os"
	"path"
	"time"

	"github.com/seventv/helm-manager/updater"
	"go.uber.org/zap"
	"gopkg.in/yaml.v3"
)

func HandleChart(chart updater.Chart, cfg updater.Config, envMap map[string]string) (updater.ChartUpgrade, bool) {
	const (
		LOCK_IDX     = 0
		VALUES_IDX   = 1
		DEFAULTS_IDX = 2
	)
	values, err := updater.ReadChartValues(chart)
	if err == updater.ErrorNotFound {
		err = nil
		zap.S().Infof("No values file found for %s, assuming first time running", chart.Name)
	}
	if err != nil {
		zap.S().Error("Unable to parse values file for %s", chart.Name)
		return updater.ChartUpgrade{}, false
	}

	if !values.IsZero() && values.Kind != yaml.DocumentNode {
		zap.S().Errorf("Invalid values file for %s", chart.Name)
		return updater.ChartUpgrade{}, false
	}

	defaultChartValues := updater.GetDefaultChartValues(chart)
	if defaultChartValues.IsZero() {
		zap.S().Errorf("No default values found for %s", chart.Name)
		return updater.ChartUpgrade{}, false
	}

	if len(values.Content) == 0 {
		values = yaml.Node{
			Kind: yaml.DocumentNode,
			Content: []*yaml.Node{{
				Kind:    yaml.MappingNode,
				Content: []*yaml.Node{},
				Tag:     "!!map",
			}, {
				Kind:    yaml.MappingNode,
				Content: []*yaml.Node{},
				Tag:     "!!map",
			}, &defaultChartValues},
		}
	} else if len(values.Content) == 1 {
		merged := updater.RemoveYamlComments(*values.Content[0])

		values.Content = []*yaml.Node{{
			Kind:    yaml.MappingNode,
			Content: []*yaml.Node{},
			Tag:     "!!map",
		}, &merged, &defaultChartValues}
	} else if len(values.Content) == 2 {
		values.Content = append(values.Content, &defaultChartValues)
	}

	if len(values.Content) != 3 {
		zap.S().Errorf("Invalid values file for %s", chart.Name)
		return updater.ChartUpgrade{}, false
	}

	oldLock := updater.ChartLock{}
	values.Content[LOCK_IDX].Decode(&oldLock)

	{
		merged := updater.PruneYaml(defaultChartValues, updater.MergeYaml(updater.RemoveYamlComments(*values.Content[DEFAULTS_IDX]), *values.Content[VALUES_IDX]))
		merged.HeadComment = "## This section contains the non-default values for this chart.\n## If you want to change a value, add it here.\n## If you want to reset a value to default, remove it here.\n## If you want to reset all values to default, delete this entire section.\n## You can also modify the section below, any changes there will be reset however they will be copied into this section.\n\n"

		values.Content[VALUES_IDX] = &merged
		values.Content[DEFAULTS_IDX] = &defaultChartValues
	}

	// marshal the full version without comments
	var envSubbedChartValuesData []byte
	{
		// remove all comments from the full version
		envSubbedChartValuesData, err = updater.MarshalYaml(updater.ToDocument(updater.RemoveYamlComments(updater.MergeYaml(*values.Content[DEFAULTS_IDX], *values.Content[VALUES_IDX]))))
		if err != nil {
			zap.S().Errorf("Failed to marshal values for %s", chart.Name)
			return updater.ChartUpgrade{}, false
		}

		// substitute the env variables into the full version without comments
		for env, value := range envMap {
			envSubbedChartValuesData = bytes.ReplaceAll(envSubbedChartValuesData, []byte(fmt.Sprintf("${%s}", env)), []byte(value))
		}
	}

	// create a new lock entry
	lock := updater.ChartLock{
		Version: chart.Version,
		Chart:   chart.Chart,
		Hash:    hex.EncodeToString(updater.Sum256(envSubbedChartValuesData)),
		Time:    time.Now(),
	}

	{ // marshal the lock entry
		lockData, err := yaml.Marshal(lock)
		if err != nil {
			zap.S().Errorf("Failed to marshal lock for %s", chart.Name)
			return updater.ChartUpgrade{}, false
		}

		lockNode := yaml.Node{}
		err = yaml.Unmarshal(lockData, &lockNode)
		if err != nil {
			zap.S().Errorf("Failed to unmarshal lock for %s", chart.Name)
			return updater.ChartUpgrade{}, false
		}

		lockNode = updater.ConvertDocument(lockNode)
		lockNode.HeadComment = "## This section is automatically generated by helm-manager. DO NOT EDIT.\n\n"
		values.Content[LOCK_IDX] = &lockNode
	}

	// allow for showing only the values that changed from the defaults.
	chartValuesData, err := updater.MarshalYaml(values)
	if err != nil {
		zap.S().Errorf("Failed to marshal values for %s", chart.Name)
		return updater.ChartUpgrade{}, false
	}

	err = os.WriteFile(chart.ValuesFile, chartValuesData, 0644)
	if err != nil {
		zap.S().Errorf("Failed to write values for %s to %s", chart.Name, chart.ValuesFile)
		return updater.ChartUpgrade{}, false
	}

	return updater.ChartUpgrade{
		Chart:            chart,
		ChartLock:        lock,
		OldLock:          oldLock,
		ValuesYaml:       chartValuesData,
		SubbedValuesYaml: envSubbedChartValuesData,
	}, true
}

func HandleUpgrade(cfg updater.Config, upgrade updater.ChartUpgrade) bool {
	zap.S().Debugf("Upgrading %s", upgrade.Chart.Name)

	chart := upgrade.Chart

	var args []string
	if cfg.Arguments.UpdateArgs.GenerateTemplate {
		args = []string{
			"template",
			chart.Name, chart.Chart,
			"--namespace", chart.Namespace,
			"--version", chart.Version,
			"--values", "-",
			"--create-namespace",
			"--include-crds",
		}
	} else {
		args = []string{
			"upgrade", "--install",
			chart.Name, chart.Chart,
			"--namespace", chart.Namespace,
			"--values", "-",
			"--version", chart.Version,
			"--create-namespace",
		}

		if cfg.Arguments.UpdateArgs.Wait {
			args = append(args, "--wait")
		}

		if cfg.Arguments.UpdateArgs.Atomic {
			args = append(args, "--atomic")
		}

		if upgrade.ChartLock.Hash == upgrade.OldLock.Hash && upgrade.ChartLock.Version == upgrade.OldLock.Version && !cfg.Arguments.UpdateArgs.ForceCharts[chart.Name] {
			zap.S().Infof("Skipping %s for upgrade, no changes detected", chart.Name)
			return true
		}
	}

	if cfg.Arguments.UpdateArgs.DryRun {
		args = append(args, "--dry-run")
	}

	output, err := updater.ExecuteCommandStdin(bytes.NewReader(upgrade.SubbedValuesYaml), "helm", args...)
	if err != nil {
		zap.S().Errorf("Failed to upgrade chart %s\n%s", chart.Name, output)
		return false
	}

	if cfg.Arguments.UpdateArgs.GenerateTemplate {
		if cfg.Arguments.UpdateArgs.TemplateOutputDir != "" {
			err = os.MkdirAll(cfg.Arguments.UpdateArgs.TemplateOutputDir, 0755)
			if err != nil {
				zap.S().Error("Failed to create directory generated templates")
				return false
			}
		}

		err = os.WriteFile(path.Join(cfg.Arguments.UpdateArgs.TemplateOutputDir, fmt.Sprintf("%s-template.yaml", chart.Name)), output, 0644)
		if err != nil {
			zap.S().Errorf("Failed to write template file for %s", chart.Name)
			return false
		}

		zap.S().Infof("Generated template for %s", chart.Name)
	} else {
		zap.S().Infof("Successfully upgraded chart %s", chart.Name)
	}

	return true
}

func main() {
	cfg := updater.GetConfig()

	zap.S().Infof("* Helm Manager Starting *")

	envMap := updater.CreateEnvMap(cfg)

	updater.ValidateCharts(cfg)
	updater.UpdateRepos(cfg)

	newLockMap := map[string]updater.ChartLock{}
	upgradeList := []updater.ChartUpgrade{}

	if len(cfg.Charts) == 0 {
		zap.S().Warn("No charts to manage")
	}

	zap.S().Debug("Updating values")

	for _, chart := range cfg.Charts {
		if cfg.Arguments.UpdateArgs.IgnoreChartsMap[chart.Name] {
			zap.S().Infof("Skipping %s, ignored", chart.Name)
			continue
		}

		chartUpgrade, success := HandleChart(chart, cfg, envMap)
		if !success {
			if cfg.Arguments.UpdateArgs.StopOnFirstError {
				zap.S().Fatalf("Failed to upgrade chart values %s", chart.Name)
			}

			continue
		} else {
			newLockMap[chart.Name] = chartUpgrade.ChartLock
			upgradeList = append(upgradeList, chartUpgrade)
		}
	}

	zap.S().Debug("Finished updating values")

	if cfg.Arguments.Mode.Update() && len(upgradeList) > 0 {
		zap.S().Debug("Updating cluster")

		for _, upgrade := range upgradeList {
			if !HandleUpgrade(cfg, upgrade) && cfg.Arguments.UpdateArgs.StopOnFirstError {
				zap.S().Fatalf("Failed to upgrade chart %s, failing fast", upgrade.Chart.Name)
			}
		}

		zap.S().Debug("Finished updating cluster")
	}

	zap.S().Infof("* Helm Manager Finished *")
}
