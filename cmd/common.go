package cmd

import (
	"bytes"
	"fmt"
	"path"
	"strings"

	"github.com/fatih/color"
	"github.com/seventv/helm-manager/external"
	"github.com/seventv/helm-manager/logger"
	"github.com/seventv/helm-manager/types"
	"github.com/seventv/helm-manager/utils"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

func ManifestExist(cmd *cobra.Command) {
	if !Manifest.Exists {
		logger.LoggerRewrite()
		logger.Fatalf("manifest does not exist yet, run\n     %s", color.YellowString("%s init", cmd.Root().Name()))
	}
}

type UpgradeResult struct {
	Document          []byte
	EnvSubbedValues   []byte
	EnvSubbedDocument *yaml.Node
	NewLock           types.ReleaseLock
	OldLock           types.ReleaseLock
}

func UpgradeDocument(data []byte, chart types.HelmChartMulti, ticker bool) (*UpgradeResult, error) {
	envMap := EnvMapFuture.GetOrPanic()

	const (
		LOCK_IDX     = 0
		VALUES_IDX   = 1
		DEFAULTS_IDX = 2
	)

	document := yaml.Node{
		Kind:    yaml.DocumentNode,
		Style:   yaml.FoldedStyle,
		Content: make([]*yaml.Node, 3),
	}

	const (
		HEAD_COMMENT_LOCK   = "## This section is automatically generated by helm-manager. DO NOT EDIT.\n\n"
		HEAD_COMMENT_VALUES = "## This section contains the non-default values for this chart.\n## If you want to change a value, add it here.\n## If you want to reset a value to default, remove it here.\n## If you want to reset all values to default, delete this entire section.\n## You can also modify the section below, any changes there will be reset however they will be copied into this section.\n\n"
	)

	if len(data) != 0 {
		node, err := utils.ParseYaml(data)
		if err != nil {
			return nil, fmt.Errorf("Failed to parse input values, %v", err)
		}

		if len(node.Content) == 1 {
			// we assume its only values
			document.Content[VALUES_IDX] = node.Content[0]
		} else if len(node.Content) == 3 {
			// we assume its lock, values and defaults
			document.Content[LOCK_IDX] = node.Content[0]
			document.Content[VALUES_IDX] = node.Content[1]
			document.Content[DEFAULTS_IDX] = node.Content[2]
		} else {
			return nil, fmt.Errorf("Input values must be a single document, or must be a 3 document yaml with the first document being the lock, the second document being the values, and the third document being the defaults")
		}
	}

	if document.Content[VALUES_IDX] == nil {
		document.Content[VALUES_IDX] = &yaml.Node{
			Kind:        yaml.MappingNode,
			Style:       yaml.FoldedStyle,
			Tag:         "!!map",
			Content:     []*yaml.Node{},
			HeadComment: HEAD_COMMENT_VALUES,
		}
	}

	oldLock := types.ReleaseLock{}
	if document.Content[LOCK_IDX] != nil {
		if err := document.Content[LOCK_IDX].Decode(&oldLock); err != nil {
			return nil, fmt.Errorf("Failed to decode lock, %v", err)
		}
	}

	var done func(bool)
	if ticker {
		done = utils.Loader(utils.LoaderOptions{
			FetchingText: fmt.Sprintf("Fetching chart %s values", chart.Name()),
			SuccessText:  fmt.Sprintf("Fetched chart %s values", chart.Name()),
			FailureText:  fmt.Sprintf("Failed to fetch chart %s values", chart.Name()),
		})
	} else {
		done = func(bool) {}
	}

	node, err := external.Helm.GetDefaultChartValues(chart.HelmChart)
	if err != nil {
		done(false)
		return nil, fmt.Errorf("Failed to fetch default values, %v", err)
	}

	defaultValues := utils.ConvertDocument(node)

	if oldLock.Version != "" && oldLock.Version != chart.Version {
		oldVersion := chart.FindVersion(oldLock.Version)
		if oldVersion.Version == "" {
			// we dont have version history for this chart
			document.Content[DEFAULTS_IDX] = defaultValues
		} else {
			node, err := external.Helm.GetDefaultChartValues(types.HelmChart(oldVersion))
			if err != nil {
				done(false)
				return nil, fmt.Errorf("Failed to parse old default values, %v", err)
			}

			oldDefaultValues := utils.ConvertDocument(node)

			document.Content[VALUES_IDX] = utils.PruneYaml(oldDefaultValues, utils.MergeYaml(utils.RemoveYamlComments(document.Content[DEFAULTS_IDX]), document.Content[VALUES_IDX]))
			document.Content[DEFAULTS_IDX] = defaultValues
		}
	}

	if document.Content[DEFAULTS_IDX] == nil {
		document.Content[DEFAULTS_IDX] = defaultValues
	}

	{
		merged := utils.PruneYaml(defaultValues, utils.MergeYaml(utils.RemoveYamlComments(document.Content[DEFAULTS_IDX]), document.Content[VALUES_IDX]))
		merged.HeadComment = HEAD_COMMENT_VALUES

		document.Content[VALUES_IDX] = merged
		document.Content[DEFAULTS_IDX] = defaultValues
	}

	var envSubbedChartValuesData []byte
	{
		// remove all comments from the full version
		envSubbedChartValuesData, err = utils.MarshalYaml(utils.ToDocument(utils.RemoveYamlComments(utils.MergeYaml(document.Content[DEFAULTS_IDX], document.Content[VALUES_IDX]))))
		if err != nil {
			done(false)
			return nil, fmt.Errorf("Failed to marshal values, %v", err)
		}

		// substitute the env variables into the full version without comments
		for env, value := range envMap {
			envSubbedChartValuesData = bytes.ReplaceAll(envSubbedChartValuesData, []byte(fmt.Sprintf("${%s}", env)), []byte(value))
		}
	}

	subbedDocument, err := utils.ParseYaml(envSubbedChartValuesData)
	if err != nil {
		done(false)
		return nil, fmt.Errorf("Failed to parse subbed values, %v", err)
	}

	newLock := types.ReleaseLock{
		Chart:   chart.RepoName,
		Version: chart.Version,
	}

	{
		lockData, err := yaml.Marshal(newLock)
		if err != nil {
			done(false)
			return nil, fmt.Errorf("Failed to marshal lock, %v", err)
		}

		lockNode := &yaml.Node{}
		if err := yaml.Unmarshal(lockData, lockNode); err != nil {
			done(false)
			return nil, fmt.Errorf("Failed to unmarshal lock, %v", err)
		}

		lockNode = utils.ConvertDocument(lockNode)
		lockNode.HeadComment = HEAD_COMMENT_LOCK
		document.Content[LOCK_IDX] = lockNode
	}

	documentData, err := utils.MarshalYaml(&document)
	if err != nil {
		done(false)
		return nil, fmt.Errorf("Failed to marshal document, %v", err)
	}

	done(true)

	return &UpgradeResult{
		NewLock:           newLock,
		OldLock:           oldLock,
		Document:          documentData,
		EnvSubbedValues:   envSubbedChartValuesData,
		EnvSubbedDocument: utils.ConvertDocument(subbedDocument),
	}, nil
}

func ReleasePath(name string) string {
	if name == "" {
		panic("Release name cannot be empty")
	}

	return path.Join(Args.Context, "releases", strings.ToLower(name)+".yaml")
}

func SinglePath(name string) string {
	if name == "" {
		panic("Single name cannot be empty")
	}

	return path.Join(Args.Context, "singles", strings.ToLower(name)+".yaml")
}

func DeployRelease(release types.ManifestRelease, chart types.HelmChart, values []byte, envSubbedDocument *yaml.Node) error {
	if !Args.Force {
		releases, err := HelmReleaseFuture.Get()
		if err != nil {
			return fmt.Errorf("Failed to get releases, %v", err)
		}

		var deployedRelease types.HelmRelease
		for _, r := range releases {
			if r.Name == release.Name {
				if r.Namespace == release.Namespace {
					deployedRelease = r
					break
				}
			}
		}
		if deployedRelease.Name != "" {
			// check if the release is already deployed
			deployed, err := external.Helm.GetDeployedReleaseValues(deployedRelease)
			if err != nil {
				logger.Debug("Failed to get deployed values for release \"%s\", %v", deployedRelease.Name, err)
			} else {
				if !utils.IsDifferent(utils.ConvertDocument(deployed), utils.ConvertDocument(envSubbedDocument)) {
					logger.Infof("Release (%s) already deployed not redeploying, use --force to override", deployedRelease.Name)
					return nil
				}
			}
		}
	}

	if Args.DryRun {
		logger.Info("Dry run, not actually deploying release")
	}

	done := utils.Loader(utils.LoaderOptions{
		FetchingText: fmt.Sprintf("Deploying release %s", release.Name),
		SuccessText:  fmt.Sprintf("Deployed release %s", release.Name),
		FailureText:  fmt.Sprintf("Failed to deploy release %s", release.Name),
	})

	resp, err := external.Helm.UpgradeRelease(release, chart, values, Args.DryRun, Args.Force)
	done(err == nil)
	if err != nil {
		return fmt.Errorf("failed to execute helm upgrade command: %v\n%s\nFailed to deploy release\n   to try again run `%s`", color.YellowString("helm-manager deploy release %s", release.Name), err, resp)
	}

	return nil
}

func DeploySingle(single types.ManifestSingle, values []byte) error {
	envMap := EnvMapFuture.GetOrPanic()

	for env, value := range envMap {
		values = bytes.ReplaceAll(values, []byte(fmt.Sprintf("${%s}", env)), []byte(value))
	}

	done := utils.Loader(utils.LoaderOptions{
		FetchingText: fmt.Sprintf("Deploying single %s", single.Name),
		SuccessText:  fmt.Sprintf("Deployed single %s", single.Name),
		FailureText:  fmt.Sprintf("Failed to deploy single %s", single.Name),
	})

	resp, err := external.Kubectl.Deploy(values, Args.Namespace, Args.AddSingleCmd.Create, Args.DryRun)
	done(err == nil)
	if err != nil {
		return fmt.Errorf("Failed to deploy single: %v\n%s", err, resp)
	}

	return nil
}
